using System;
using Zhichkin.ORM;
using System.Collections.Generic;
using Zhichkin.Metadata.Model;

namespace Zhichkin.Integrator.Model
{
    public sealed partial class Subscription : EntityBase
    {
        private static readonly IDataMapper _mapper = IntegratorPersistentContext.Current.GetDataMapper(typeof(Subscription));
        public static IList<Subscription> Select() { return DataMapper.Select(); }
        public static Subscription Select(Guid identity) { return DataMapper.Select(identity); }
        public static IList<Subscription> Select(Publisher publisher) { return DataMapper.Select(publisher); }

        public Subscription() : base(_mapper) { }
        public Subscription(Guid identity) : base(_mapper, identity) { }
        public Subscription(Guid identity, PersistentState state) : base(_mapper, identity, state) { }

        private Publisher publisher = null;
        private Entity subscriber = null;
        private List<TranslationRule> rules = new List<TranslationRule>();

        ///<summary>Publisher (data source)</summary>
        public Publisher Publisher { set { Set<Publisher>(value, ref publisher); } get { return Get<Publisher>(ref publisher); } }
        ///<summary>Subscriber (data target)</summary>
        public Entity Subscriber { set { Set<Entity>(value, ref subscriber); } get { return Get<Entity>(ref subscriber); } }
        ///<summary>Translation rules</summary>
        public IList<TranslationRule> TranslationRules
        {
            get
            {
                if (this.state == PersistentState.New) return rules;
                if (rules.Count > 0) return rules;
                return DataMapper.GetTranslationRules(this);
            }
        }
        public TranslationRule CreateTranslationRule()
        {
            return new TranslationRule()
            {
                Source = publisher.Entity,
                Target = subscriber
            };
        }
        public override string ToString()
        {
            return string.Format("{0} -> {1}",
                this.Publisher == null ? string.Empty : this.Publisher.Name,
                this.Subscriber == null ? string.Empty : this.Subscriber.FullName);
        }

        // default collision resolution strategy
        /// <summary>
        /// Insert-Insert collision (duplicate primary key exception)
        /// </summary>
        public CollisionResolutionStrategy OnInsertCollision { get { return CollisionResolutionStrategy.Update; } }
        /// <summary>
        /// Update-Delete collision (zero rows affected exception)
        /// </summary>
        public CollisionResolutionStrategy OnUpdateCollision { get { return CollisionResolutionStrategy.Insert; } }
        /// <summary>
        /// Delete-Delete collision (zero rows affected exception)
        /// </summary>
        public CollisionResolutionStrategy OnDeleteCollision { get { return CollisionResolutionStrategy.Ignore; } }

        //
        private Dictionary<string, Field> _mappings = null; // data transfer fields between publisher and subscriber
        private List<Field> _bindings = null; // sync fields between publisher and subscriber
        private List<Field> _defaults = null; // subscriber fields which have no mapping to set default values (not null fields)
        private void SetupFieldCollections()
        {
            // prepare defaults
            if (_defaults == null) _defaults = new List<Field>();
            _defaults.Clear();
            foreach (Property property in this.Subscriber.Properties)
            {
                foreach (Field field in property.Fields)
                {
                    if (field.IsNullable) continue;
                    if (Utilities.IsAutoGeneratedValue(field)) continue; // version
                    _defaults.Add(field);
                }
            }

            // mappings and bindings
            if (_mappings == null) _mappings = new Dictionary<string, Field>();
            if (_bindings == null) _bindings = new List<Field>();
            _mappings.Clear();
            _bindings.Clear();
            foreach (TranslationRule rule in this.TranslationRules)
            {
                foreach (Field source_field in rule.SourceProperty.Fields)
                {
                    if (Utilities.IsAutoGeneratedValue(source_field)) continue; // version
                    foreach (Field target_field in rule.TargetProperty.Fields)
                    {
                        // fields are mapped between each other by it's purpose
                        if (source_field.Purpose == target_field.Purpose)
                        {
                            _mappings.Add(source_field.Name, target_field);
                            if (rule.IsSyncKey) _bindings.Add(source_field);
                            if (_defaults.Contains(target_field)) _defaults.Remove(target_field);
                            break; // once mapped - take next source field to map
                        }
                    }
                }
            }
        }
        public Dictionary<string, Field> Mappings
        {
            get
            {
                if (_mappings == null) SetupFieldCollections();
                return _mappings;
            }
        }
        public List<Field> Bindings
        {
            get
            {
                if (_bindings == null) SetupFieldCollections();
                return _bindings;
            }
        }
        public List<Field> Defaults
        {
            get
            {
                if (_defaults == null) SetupFieldCollections();
                return _defaults;
            }
        }
    }
}
